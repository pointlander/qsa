/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

// source: liblsl_c.i

package liblsl

import (
	"C"
	"fmt"
)

/*
#define intgo swig_intgo
typedef void *swig_voidp;

#include <stdint.h>
#include <stdlib.h>
#include "/Users/andrew/projects/labstreaminglayer/LSL/liblsl/include/lsl_c.h"

#cgo LDFLAGS: -llsl

typedef long long intgo;
typedef unsigned long long uintgo;



typedef struct { char *p; intgo n; } _gostring_;
typedef struct { void* array; intgo len; intgo cap; } _goslice_;


extern void _wrap_Swig_free_liblsl_0c9cead307ce20a1(uintptr_t arg1);
extern uintptr_t _wrap_Swig_malloc_liblsl_0c9cead307ce20a1(swig_intgo arg1);
#undef intgo
*/
import "C"

import "unsafe"
import _ "runtime/cgo"
import "sync"

type _ unsafe.Pointer

var Swig_escape_always_false bool
var Swig_escape_val interface{}

type _swig_fnptr *byte
type _swig_memberptr *byte

type _ sync.Mutex

func Swig_free(arg1 uintptr) {
	_swig_i_0 := arg1
	C._wrap_Swig_free_liblsl_0c9cead307ce20a1(C.uintptr_t(_swig_i_0))
}

func Swig_malloc(arg1 int) (_swig_ret uintptr) {
	var swig_r uintptr
	_swig_i_0 := arg1
	swig_r = (uintptr)(C._wrap_Swig_malloc_liblsl_0c9cead307ce20a1(C.swig_intgo(_swig_i_0)))
	return swig_r
}

func Start() C.lsl_inlet {
	buffer := C.malloc(C.size_t(unsafe.Sizeof(C.struct_lsl_streaminfo{})))
	defer C.free(buffer)
	property := C.CString("type")
	defer C.free(unsafe.Pointer(property))
	value := C.CString("EEG")
	defer C.free(unsafe.Pointer(value))
	streams := C.lsl_resolve_byprop((*C.lsl_streaminfo)(buffer), 1, property, value, 0, .2)
	fmt.Println(streams)
	if streams > 0 {
		name := C.lsl_get_name(*(*C.lsl_streaminfo)(buffer))
		fmt.Println(C.GoString(name))
		count := C.lsl_get_channel_count(*(*C.lsl_streaminfo)(buffer))
		fmt.Println("channel count", count)
		format := C.lsl_get_channel_format(*(*C.lsl_streaminfo)(buffer))
		fmt.Println("channel format", format)
		inlet := C.lsl_create_inlet(*(*C.lsl_streaminfo)(buffer), 360, 0, 1)
		var ec int32
		C.lsl_open_stream(inlet, 1, (*C.int32_t)(unsafe.Pointer(&ec)))
		if ec != 0 {
			panic("error opening stream")
		}
		return inlet
	}
	return nil
}

func Sample(inlet C.lsl_inlet) {
	buffer := C.malloc(C.size_t(5 * 4))
	defer C.free(buffer)
	var ec int32
	c := C.lsl_pull_sample_f(inlet, (*C.float)(buffer), 5, 10, (*C.int32_t)(unsafe.Pointer(&ec)))
	if ec != 0 {
		panic(fmt.Errorf("error pulling sample: %d", ec))
	}
	if c > 0 {
		for i := 0; i < 5; i++ {
			fmt.Println(*(*float32)(unsafe.Pointer(uintptr(buffer) + uintptr(i*4))))
		}
	}
}

func Stop(inlet C.lsl_inlet) {
	C.lsl_close_stream(inlet)
	C.lsl_destroy_inlet(inlet)
}
